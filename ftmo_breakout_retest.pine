//@version=5
strategy("FTMO Breakout + Pullback (Asia/PrevDay) — v1", overlay=true, initial_capital=50000, commission_type=strategy.commission.cash_per_contract, commission_value=0.0, calc_on_every_tick=false, calc_on_order_fills=true, process_orders_on_close=true, pyramiding=0, max_labels_count=500)

// ===================== Inputs ===================== //
// Risk & Targets
riskUSD              = input.float(250.0,  "Risk per trade (USD)")
rrMultiple           = input.float(2.0,    "TP multiple (R)")
slPtsMin             = input.int(20,       "Min SL distance (pts)", minval=1)

// Sessions (exchange time)
session1             = input.session("0900-1100", "Session 1 (HHMM-HHMM)")
session2             = input.session("1530-1700", "Session 2 (HHMM-HHMM)")
limitToSessions      = input.bool(true, "Trade only inside sessions")
oneTradePerSession   = input.bool(true, "One trade per session")
maxLossesPerDay      = input.int(2, "Max losing trades per day", minval=1)
dailyMaxLossUSD      = input.float(-2500, "FTMO daily max loss (USD)")
maxTotalLossUSD      = input.float(-5000, "FTMO max loss (USD)")

// Levels
useAsiaLevels        = input.bool(true,  "Use Asia High/Low (00:00–08:00)")
asiaStartHour        = input.int(0, "Asia start hour", minval=0, maxval=23)
asiaEndHour          = input.int(8, "Asia end hour", minval=1, maxval=23)
usePrevDayLevels     = input.bool(true,  "Use Previous Day High/Low")
pullbackTolerancePts = input.int(10,     "Pullback tolerance (pts)", minval=1)
minBreakCandleRange  = input.int(20,     "Min breakout candle range (pts)", minval=1)

// Instrument economics (for sizing & backtest only)
pointValueUSD        = input.float(10.0,  "$ per point per contract", tooltip="Ex: DAX cash ~ $10/pt; US100 cash often ~$1/pt at some brokers. Adjust to your symbol.")
qtyMin               = input.float(0.1,   "Min qty (contracts)", step=0.01)
qtyStep              = input.float(0.1,   "Qty step", step=0.01)

// Daily soft stop (optional, backtest helper)
useDailySoftStop     = input.bool(true,   "Use daily soft stop")
dailySoftStopUSD     = input.float(-500,  "Soft stop P&L for the day (USD)")

// Visuals
plotAsiaRange        = input.bool(true, "Plot Asia H/L")
plotPrevDayRange     = input.bool(true, "Plot Prev Day H/L")

// ===================== Helpers ===================== //
inSes(sess) =>
    time(timeframe.period, sess)
session1Active = inSes(session1)
session2Active = inSes(session2)
isNewDay  = ta.change(time("D"))

var bool  session1Done = false
var bool  session2Done = false
var int   lossesToday  = 0
var float dayStartNet  = na
if isNewDay
    dayStartNet := strategy.netprofit
    session1Done := false
    session2Done := false
    lossesToday  := 0

sess1OK = session1Active and (not oneTradePerSession or not session1Done)
sess2OK = session2Active and (not oneTradePerSession or not session2Done)

intradayPnL      = strategy.netprofit - nz(dayStartNet, strategy.netprofit)
softStopHit      = useDailySoftStop and intradayPnL <= dailySoftStopUSD
hardDailyLossHit = intradayPnL <= dailyMaxLossUSD
totalLossHit     = strategy.netprofit <= maxTotalLossUSD
var float tradeStartNet = na
if strategy.position_size[1] == 0 and strategy.position_size != 0
    tradeStartNet := strategy.netprofit
if strategy.position_size[1] != 0 and strategy.position_size == 0
    tradePnL = strategy.netprofit - nz(tradeStartNet, strategy.netprofit)
    if tradePnL < 0
        lossesToday += 1

lossLimitHit     = lossesToday >= maxLossesPerDay

canTradeSession = not limitToSessions or sess1OK or sess2OK
canTrade        = canTradeSession and not softStopHit and not hardDailyLossHit and not totalLossHit and not lossLimitHit

prevHigh = usePrevDayLevels ? request.security(syminfo.tickerid, "D", high[1], barmerge.gaps_on, barmerge.lookahead_on) : na
prevLow  = usePrevDayLevels ? request.security(syminfo.tickerid, "D", low[1],  barmerge.gaps_on, barmerge.lookahead_on) : na

inAsia = (hour >= asiaStartHour and hour < asiaEndHour)
var float asiaHi = na
var float asiaLo = na
if isNewDay
    asiaHi := na
    asiaLo := na
if inAsia
    asiaHi := na(asiaHi) ? high : math.max(asiaHi, high)
    asiaLo := na(asiaLo) ? low  : math.min(asiaLo, low)

clrAsia = color.new(color.aqua, 0)
clrPrev = color.new(color.orange, 0)
plot(plotAsiaRange and useAsiaLevels ? asiaHi : na,  title="Asia High", color=clrAsia,  style=plot.style_linebr)
plot(plotAsiaRange and useAsiaLevels ? asiaLo : na,  title="Asia Low",  color=clrAsia,  style=plot.style_linebr)
plot(plotPrevDayRange and usePrevDayLevels ? prevHigh : na, title="Prev High", color=clrPrev, style=plot.style_linebr)
plot(plotPrevDayRange and usePrevDayLevels ? prevLow  : na, title="Prev Low",  color=clrPrev, style=plot.style_linebr)

// ===================== Breakout + Pullback Logic ===================== //
o1 = open[1]
c1 = close[1]
h1 = high[1]
l1 = low[1]
rangeOK = (h1 - l1) >= minBreakCandleRange * syminfo.mintick

levels = array.new_float()
if useAsiaLevels and not na(asiaHi)
    array.push(levels, asiaHi)
if useAsiaLevels and not na(asiaLo)
    array.push(levels, asiaLo)
if usePrevDayLevels and not na(prevHigh)
    array.push(levels, prevHigh)
if usePrevDayLevels and not na(prevLow)
    array.push(levels, prevLow)

breakLong  = false
breakShort = false
float breakLevel = na

for i = 0 to array.size(levels)-1
    lv = array.get(levels, i)
    if not na(lv)
        if c1 > lv and o1 < lv and rangeOK
            breakLong := true
            breakLevel := lv
        if c1 < lv and o1 > lv and rangeOK
            breakShort := true
            breakLevel := lv

var bool  pending      = false
var bool  pendingLong  = false
var float pendingLevel = na
var int   pendingSLpts = 0
var bool  tradeIsLong  = false
var float tradeSL      = na
var float tradeTP      = na
var float tradeRisk    = na
var bool  movedToBE    = false

if (breakLong or breakShort) and canTrade
    pending      := true
    pendingLong  := breakLong
    pendingLevel := breakLevel
    pendingSLpts := math.max(minBreakCandleRange, int(math.round((h1 - l1) / syminfo.mintick)))

closeNow = close
openNow  = open
highNow  = high
lowNow   = low
nearTol  = pullbackTolerancePts * syminfo.mintick

rejectionOKLong  = pending and pendingLong  and ((lowNow <= pendingLevel + nearTol) and (closeNow > openNow) and (closeNow >= pendingLevel))
rejectionOKShort = pending and not pendingLong and ((highNow >= pendingLevel - nearTol) and (closeNow < openNow) and (closeNow <= pendingLevel))

entryLong  = rejectionOKLong
entryShort = rejectionOKShort

slPriceLong  = pendingLevel - nearTol
slPriceShort = pendingLevel + nearTol
slPtsLong    = math.max(pendingSLpts,  int(math.round((closeNow - slPriceLong)  / syminfo.mintick)))
slPtsShort   = math.max(pendingSLpts,  int(math.round((slPriceShort - closeNow) / syminfo.mintick)))

distLong  = slPtsLong  * syminfo.mintick
distShort = slPtsShort * syminfo.mintick

getQty(dist) =>
    pts = dist / syminfo.mintick
    raw = riskUSD / (pts * pointValueUSD)
    stepped = math.floor(raw / qtyStep) * qtyStep
    math.max(qtyMin, stepped)

qtyLong  = getQty(distLong)
qtyShort = getQty(distShort)

float longTP  = na
float shortTP = na
if entryLong
    longTP := closeNow + rrMultiple * distLong
if entryShort
    shortTP := closeNow - rrMultiple * distShort

if canTrade
    if entryLong and distLong >= slPtsMin * syminfo.mintick
        tradeIsLong := true
        tradeSL     := slPriceLong
        tradeTP     := longTP
        tradeRisk   := distLong
        movedToBE   := false
        strategy.entry("LONG", strategy.long, qty=qtyLong)
        strategy.exit("LX", from_entry="LONG", stop=tradeSL, limit=tradeTP)
        label.new(bar_index, close, text="LONG @ "+str.tostring(close, format.mintick)+"\nSL "+str.tostring(tradeSL, format.mintick)+"\nTP "+str.tostring(tradeTP, format.mintick), style=label.style_label_up, textcolor=color.white, color=color.new(color.teal, 0))
        pending := false
        if session1Active
            session1Done := true
        if session2Active
            session2Done := true
    if entryShort and distShort >= slPtsMin * syminfo.mintick
        tradeIsLong := false
        tradeSL     := slPriceShort
        tradeTP     := shortTP
        tradeRisk   := distShort
        movedToBE   := false
        strategy.entry("SHORT", strategy.short, qty=qtyShort)
        strategy.exit("SX", from_entry="SHORT", stop=tradeSL, limit=tradeTP)
        label.new(bar_index, close, text="SHORT @ "+str.tostring(close, format.mintick)+"\nSL "+str.tostring(tradeSL, format.mintick)+"\nTP "+str.tostring(tradeTP, format.mintick), style=label.style_label_down, textcolor=color.white, color=color.new(color.maroon, 0))
        pending := false
        if session1Active
            session1Done := true
        if session2Active
            session2Done := true

if strategy.position_size > 0 and tradeIsLong
    entryPrice = strategy.position_avg_price
    if not movedToBE and high >= entryPrice + tradeRisk
        tradeSL := entryPrice
        movedToBE := true
    strategy.exit("LX", from_entry="LONG", stop=tradeSL, limit=tradeTP)
if strategy.position_size < 0 and not tradeIsLong
    entryPrice = strategy.position_avg_price
    if not movedToBE and low <= entryPrice - tradeRisk
        tradeSL := entryPrice
        movedToBE := true
    strategy.exit("SX", from_entry="SHORT", stop=tradeSL, limit=tradeTP)

// ===================== Notes ===================== //
// ALERTS: TradingView interdit alertcondition() dans les strategies.
// => Pour le live, il faut convertir ce script en "study" (indicator) et y mettre les alertcondition.
// Ici, tu peux simplement créer une alerte manuelle sur les trades ("strategy order fill") ou dupliquer le code en version indicator.
